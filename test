# Стандарт кодирования на C++ (Beta)

1.  [Назначение и область применения](#1-назначение-и-область-применения)
2.  [Форматирование](#2-форматирование)
3.  [Имена](#3-имена)
4.  [Комментарии](#4-комментарии)
5.  [Заголовочные файлы и файлы реализации](#5-заголовочные-файлы-и-файлы-реализации)
6.  [Модули и пространства имен](#6-модули-и-пространства-имен)
7.  [Классы](#7-классы)
8.  [Функции](#8-функции)
9.  [Умные указатели и управление памятью](#9-умные-указатели-и-управление-памятью)
10. [Обработка ошибок, исключения](#10-обработка-ошибок-исключения)
11. [Типы и их преобразования](#11-типы-и-их-преобразования)
12. [Операторы и выражения](#12-операторы-и-выражения)
13. [Сonst-корректность](#13-сonst-корректность)
14. [Макросы](#14-макросы)
15. [Отдельные элементы C++11](#15-отдельные-элементы-c11)

## 1. Назначение и область применения.

Документ описывает стандарт кодирования на языке C++. Следование данному стандарту является обязательным в отделе "Поиск" при разработке на языке программирования C++.

## 2. Форматирование.

### 2.1. В пределах одного файла должен использоваться единый стиль форматирования.

Если нужно внести небольшие изменения в уже написанный программный модуль, то следует придерживаться стилю форматирования кода, изначально присутствующему в редактируемом файле, даже если для этого придётся отклониться от правил, указанных в данном стандарте.

### 2.2. В пределах одного проекта стиль форматирования кода должен выбираться по согласованию с автором (maintainer) проекта.

Проект может быть достаточно большим, и написанным в едином выдержанном стиле. При редактировании существующих файлов - этот стиль должен быть выдержан. При добавлении же новых файлов, по согласованию с автором (maintainer) проекта, для них должен выбираться либо тот же самый стиль, в котором уже написан весь проект, либо стиль, который описан в данном стандарте кодирования.

При написании же новых проектов, **всегда** должен выбираться только стиль, описанный в данном стандарте кодирования.

### 2.3. Длина строки в *.cpp , *.hpp файлах не более 120 символов.

_Если длина строки превосходит данное значение, то код становится тяжело читаемым._ Некоторые люди привыкли иметь несколько окон кода рядом друг с другом, кто-то имеет дополнительный монитор в вертикальном положении, чтоб видеть больше. Люди настраивают свою рабочую среду, предполагая определённую максимальную ширину окна. Обычно 80 столбцов является традиционным стандартом, например, в Google. Мы выбрали 120.

### 2.4. Величина отступов для форматирования исходного кода - 4 пробела.

_При использовании пробелов код будет выглядеть одинаково во всех редакторах вне зависимости от настроек редактора._

### 2.5. Одна строка — один оператор.

**_Пример:_**

```cpp
// Неверно
if( *ptr != '/' )
    --ptr, --idx;

// Верно
if( *ptr != '/' )
{
    --ptr;
    --idx;
}

// Неверно
int some_var = 0; CallSomething( some_var );

// Верно
int some_var = 0;
CallSomething( some_var );
```

### 2.6. Выделяйте логически связанные части исходного кода отступами и переводами строк.

_Правильный в отношении логики выполнения программы, но неправильный в отношении оформления код затрудняет сопровождение кода несколькими разработчиками._

**_Пример:_**

```cpp
// Неверно
bool Session::SelectNextNode()
{
    size_t node_num = pool_.GetNodeNum();
    if( try_counter_ == node_num ) return false;
    curr_node_ = ( curr_node_ + 1 ) % node_num;
    ++try_counter_;
    conn_ptr_ = pool_.EstablishConnection( curr_node_ );
    if( !conn_ptr_ ) return SelectNextNode();
    conn_ptr_->SetSession( *this );
    ResetInactiveTimeout();
    return true;
}

// Верно
bool Session::SelectNextNode()
{
    size_t node_num = pool_.GetNodeNum();
    if( try_counter_ == node_num )
        return false;

    curr_node_ = ( curr_node_ + 1 ) % node_num;
    ++try_counter_;

    conn_ptr_ = pool_.EstablishConnection( curr_node_ );
    if( !conn_ptr_ )
        return SelectNextNode();

    conn_ptr_->SetSession( *this );
    ResetInactiveTimeout();
    return true;
}
```

### 2.7. Другие требования по форматированию кода.

* **Выравнивайте соответствующие друг другу скобки по вертикали.**

```cpp
// Выравнивание скобок по вертикали
while( n > 10 )
{
    if( condition )
    {
        //...
    }
}
```

* **Не используйте "египетские скобки" OTBS, у нас принято Allman style.**

**_Пример:_**

```cpp
// Неверно
if( condition ) {
    for( size_t i = 0; i < 10; ++i ) {
        DoSomeWork();
        AndSomeOtherWork();
    }
}

// Верно
if( condition )
{
    for( size_t i = 0; i < 10; ++i )
    {
        DoSomeWork();
    }
}
```

* **Операторные скобки после if/while/for ставятся всегда, кроме однострочной области видимости оператора.**

```cpp
// Некорректно! область видимости этого if - две строки, значит нужно ставить операторные скобки
if( x > 5 )
    if( y > 10 )
        throw std::runtime_error( "too much" );

// Исправленный вариант
if( x > 5 )
{
    if( y > 10 )
        throw std::runtime_error( "too much" );
}
```

* **Не используйте NULL, вместо него всегда используйте nullptr**

```cpp
class SpawnFutureImpl 
:   public SpawnFuture
{
    void SetHolder( Spawner * holder = nullptr );

private:
    Spawner * holder_ = nullptr;
    ProcessId pid_ = 0;
};
```

* **Делайте пробельный интервал после запятой (,) и точки с занятой (;)**

```cpp
// Пробел после запятой и точки с запятой
for( size_t i = 0, size = numbers.size(); i < size && ptr != nullptr; ++i )
{
    //...
}
```

* **Не используйте пробелы на концах строк.**
* **Ставьте пробел до и после бинарных операторов (+, -, &, == и т.п.)**

```cpp
// Пробел и операторы
int result = coeff * factor + add;

// Использование сложного условного оператора
int is_blocked = ( !mob_number.empty() && IsBlocked( mob_number ) ) ? 1 : 0;
```

* **В бинарном операторе "==", при сравнении с константой, переменную следует писать с левой стороны. Наш код собирается с -Wparentheses, что должно исключить связанный с этим класс ошибок.**

```cpp
// Некорректно! Менять порядок аргументов не следует, т.к. ошибочные присваивания уже проверяются компилятором
if( 123 == index )
{
    //...
}

// Исправленный вариант
if( index == 123 )
{
    //...
}
```

* **Если у функции много аргументов, и ее вызов не умещается на одну строку, то используйте выравнивание по уровню >= уровня открывающей скобки.**

```cpp
// Функция со многими аргументами
MakeCall( expr1, expr2, expr3,
          expr4, expr5 );
```

* **При переносе кода на новую строку, заканчивайте строку оператором.**

```cpp
// Перенос выражения на новую строку
int result = num1 + num2 +
             num3 + num4;

if( IsVeryLongFunctionName() &&
    IsOtherVeryLongFunctionName() &&
    a > b )
{
    DoImportantStuff();
}
```

* **Пробел ставится после открывающей скобки и перед закрывающей.**

```cpp
if( condition )
{
    for( size_t i = 0; i < 10; ++i )
    {
        // ...
    }
}

// Касается также угловых скобок, квадратных скобок и списков инициализации.
std::vector< int > numbers = { 1, 2, 3 };
```

* **После объявления namespace не делайте отступ (indent) для последующего кода.**
* **Имя секции в классе (public, protected, private) также не имеет отступа.**

```cpp
namespace gogo
{
namespace companies_ranker
{

class CompaniesRanker
:   public XmlRanker
{
public:
    CompaniesRanker( const RankerConfig & config );

private:
    virtual void AddDocToRank( const BestDocsList & docs, DocDataExList & ranks ) override;

private:
    TextFeaturizer text_featurizer_;
    TraitHolder * trait_holder_;
};

} // namespace companies_ranker
} // namespace gogo
```

* **При объявлении ссылки и указателя, символы & и * должны быть отделены от переменной пробелом с 2-х сторон.**

```cpp
// Объявление ссылки
int & ref = i;

// Объявление указателя
int * ptr = &i;
```

* **При объявлении константного типа, слово сonst указывается первым ( const int & value )**

```cpp
int64_t CreateObject( const std::string & name );
```

* **Список инициализации в конструкторе начинается с новой строки. Двоеточие ставится в начале строки, запятые - в конце.**

```cpp
// Оформление списка инициализации в конструкторе
DerivedClass::DerivedClass( int base_arg, int arg1, bool arg2 )
:   BaseClass( base_arg ),
    member1_( arg1 ),
    member2_( arg2 )
{
    // один отступ для кода конструктора
    int z = 0;
    //...
}
```

* **Два вида оформления для оператора switch: сокращённый и полный. В сокращённом break ставится на той же строке, что и case. Сокращённый можно использовать только если тело case состоит из одного выражения. В полном варианте после break ставится пустая строка, в сокращённом - нет. Допускается заменять break атрибутом "[[fallthrough]];", обозначающим проваливание в нижеследующий case. Для пустых блоков case [[fallthrough]] не нужен.**

```cpp
// Полный вариант
switch( cup_size )
{
case 'A':
    // do nothing
    break;

case 'B':
    Smirk();
    [[fallthrough]];

case 'C':
    int precise_size = InspectClosely();
    printf( "Wow! %d cm\n", precise_size );
    break;

case 'D': // пустой блок case, поэтому не ставим [[fallthrough]];
default:
    RunAway();
}

// Сокращённый вариант
switch( cup_size )
{
case 'A': /* do nothing */ break;
case 'B': Smirk(); [[fallthrough]];
case 'C': printf( "Wow! %d cm\n", InspectClosely() ); break;
case 'D': // пустой блок case, поэтому не ставим [[fallthrough]];
default: RunAway();
}
```

* **Не используйте оператор goto, поскольку всегда можно обойтись без него. А ещё goto considered harmful.**
 
* **После определения функции или класса (definition) обязательно должна быть пустая строка. После объявления (declaration) - не обязательно.**

```cpp
namespace cosmo
{

// Объявление
class BestDocsQueue
{
public:
    BestDocsQueue( size_t max_size, bool use_simhash );
    ~BestDocsQueue();

    void Push( const RankedDocument & doc );
    void Release( std::vector< RankedDocument > & result );
    size_t Size() const { return entries_.size(); }

private:
    struct Stats
    {
        float max_rank;
        int count;
    };

    typedef std::unordered_map< int64_t, Stats > Index;

    struct Refs
    {
        Index::value_type * by_doc_id = nullptr;
        Index::value_type * by_simhash = nullptr;
    };

private:
    bool IsFull() const;
    bool IsOverflow() const;
    bool IsBetterThanWorst( const RankedDocument & doc ) const;
    bool CanRemoveWorst() const;

private:
    const bool use_simhash_;
    const size_t max_size_;
};

// Определение
BestDocsQueue::BestDocsQueue( size_t max_size, bool use_simhash )
:   use_simhash_( use_simhash ),
    max_size_( max_size ),
    copies_count_( 0 )
{
    entries_.reserve( max_size * 3 );
    doc_id_index_.reserve( max_size * 1.5 );
    simhash_index_.reserve( max_size * 1.5 );
}

BestDocsQueue::~BestDocsQueue()
{}

} // namespace cosmo
```

## 3. Имена.

### 3.1. Названия файлов и директорий.

Заголовочные файлы должны иметь расширение *.hpp*, а файлы реализации - расширение *.cpp*

Все файлы и директории должны называться в стиле с подчеркиваниями, например *spell_checker.hpp*

### 3.2. Имена идентификаторов в программе должны отражать назначение данного класса, переменной, метода или параметра. Желательно делать имена параметров короткими, насколько это возможно, но не в ущерб читаемости.

Не используйте сокращения, которые неоднозначны или незнакомы читателям за пределами вашего проекта.

Не сокращайте сильно имена, удаляя буквы в слове, за исключением общепринятых (num, src, ptr).

Методам и переменным нужно присваивать имена в соответствии с их назначением.

Имя класса должно описывать его обязанность.

**_Пример:_**

```cpp
// Неверно
int f( char * i, int j, int k );

// Верно
size_t copy( char * s, size_t len, size_t pos = 0 );
```

### 3.3. Требования к именованию переменных.

Для названий типов class, struct, enum class надо использовать CamelCase с большой буквы.

Для имён переменных использовать unix_style. Статические, глобальные константы и перечисления в верхнем регистре MAX_ENUM_VALUE.

Имя члена класса заканчивается подчеркиванием. В аргументах функции недопустимо объявлять переменные с префиксом "a_" и постфиксом "_".

**_Пример:_**

```cpp
class Test
{
    ...
private:
    int count_;
};

enum class HttpStatus
{
    OK = 200,
    BAD_REQUEST = 400,
    INTERNAL_SERVER_ERROR = 500,
    SERVICE_UNAILABLE = 503,
};

// Неверно
void f( int a_param1, int param2_ );
```

### 3.4. Имена методов должны начинаться с заглавной буквы и первым словом должен быть глагол.

Такой способ именования выбран, чтобы легко отличать методы проекта, от системных функций unix и методов стандартной библиотеки С++.

**_Пример:_**

```cpp
SetContour( ... )
LoadParametersFromFile( ... )
InitModel( ... )
```

Имена методов возвращающих true или false, желательно начинать с "Is" или "Has", вопроса имеющего ответ да или нет.

**_Пример:_**

```cpp
IsUnicode( ... )
HasMoreElements( ... )
```

### 3.5. Все #define идентификаторы определяются в верхнем регистре.

**_Пример:_**

```cpp
#define MAX_MESSAGE_COUNT 1000
```

Настоятельно рекомендуется свести количество #define к минимуму. Желательно использовать const и enum class вместо них.

### 3.6. Имена классов пишутся в CamelCase, с большой буквы и не содержат в себе символов нижнего подчеркивания. Имена классов должны представлять собой существительное.

**_Пример:_**

```cpp
// Неверно
class session_logger { ... };

// Верно
class SessionLogger { ... };
```

He используйте двух подряд идущих заглавных букв внутри имени класса. Даже если это аббревиатура (URL, IP, DNS), рассматривайте его как слово, в котором только первая буква - заглавная.

**_Пример:_**

```cpp
// Неверно
class URLTable { ... }

// Верно
class UrlTable { ... };
```

### 3.7. Шаблоны.

Для описания параметров шаблонов используйте ключевое слово typename, никаких префиксов для названий не требуется.

```cpp
// Неверно
template< class TParam >

// Верно
template< typename Param >
```

## 4. Комментарии.

### 4.1. Требования к комментариям.

Общие требования:

* Комментарии можно писать как на русском языке, так и на английском. Предпочтительней на английском.
* В реализации методов комментарии должны описывать логику работы кода.
* Все неочевидные моменты в коде должны быть прокомментированы. Не стоит комментировать очевидные вещи.
* Комментировать описания классов или методов необходимо только в заголовочном файле, в файл реализации комментарии переносить необязательно.

Отдельные требования:

* Можно использовать синтаксис // или / * * /; Однако, // более предпочтителен.
* Сложные или неочевидные блоки кода должны содержать комментарии перед ними.
* Допустимо размещать комментарий в той же строке, что и комментируемый код, если суммарная длина строки с комментарием не будет превышать установленный ранее лимит в 120 символов. В ином случае комментарий стоит размещать перед строкой с кодом.

**_Пример описания функции:_**

```cpp
// Данный метод создает объект по имени "name"
// и возвращает ID только что созданного объекта.
// Если такой объект уже был создан,
// то выбрасывается исключение std::logic_error.
int64_t CreateObject( const std::string & name );
```

**_Пример описания класса:_**

```cpp
/*
 * Class coro::VariantFuture is like a boost::variant, but it copies coro::Future interface/semantics
 * It can be used for storing and processing futures in heterogeneous containers without knowing of particular future type
 * This class should be used with coro::Future (and inheritors) or std::unique_ptr< coro::Future >
 *
 * usage example:
 *      typedef VariantFuture< HTTP_Future, FTP_Future, SSH_Future > RequestFuture;
 *
 *      // std::vector has more strict rules for contained type
 *      boost::container::vector< RequestFuture > requests = {
 *          HTTP_Future( "http://mail.ru" ),
 *          FTP_Future( "ftp://strawberry.com" ),
 *          SSH_Future( "ssh://my-super-secure-hetzner-server.de" )
 *      };
 *
 *      auto fired_future_iterator = coro::Coroutine::GetCurrent().WaitForAny( requests );
 *      switch( fired_future_iterator->which() )
 *      {
 *          case 0: std::cout << "HTTP was first!" << std::endl; break;
 *          case 1: std::cout << "FTP is the fastest!" << std::endl; break;
 *          case 2: std::cout << "SSH? I can't believe that!" << std::endl; break;
 *      }
 */

template < typename ... FutureTypes >
class VariantFuture
:   public boost::variant< FutureTypes ... >
{
public:
    friend class Coroutine;
    ...
};
```

**_Пример описания класса:_**

```cpp
class Coroutine
:   boost::noncopyable
{
public:
    // yes, we're using old plain-C pattern
    // but IMHO it's better than mess with template parameter to class Coroutine
    typedef void *UserData;

public:
    ...

private:
    typedef boost::coroutines::coroutine< int /* waiting_id */ > Coro;

private:
    ...

    // coroutine where we are (pointer switched during stack changing)
    static Coroutine * current_;

    // pointer to destroyed flag
    // we can't check class member directly
    // because it'll be destroyed
    bool * destroyed_;
};

// due to gcc bug
template < typename ... FutureTypes >
class VariantFuture;

template < typename ResultType >
class Future
{
public:
    void Then( const ThenCallback & then )
    {
        then_ = then;
        if( HasResult() )
            then_(); // if we already have result then call it immediately
    }

    template < typename ForwardType >
    void SetResult( ForwardType && result )
    {
        result_ = std::forward< ForwardType >( result );
        if( then_ )
        {
            then_();
        }
        // we really need this strange condition
        // because then-callback may totally destroy current runtime (stack)
        // and next statement will raise segfault
        else if( waiting_id_ != INVALID_WAITING_ID )
        {
            holder_->WakeUp( waiting_id_ );
        }
    }
    ...
};
```

## 5. Заголовочные файлы и файлы реализации.

### 5.1. Заголовочные файлы необходимо защищать от повторного включения с помощью #pragma once.

Не нужно использовать стражники включения с использованием #ifndef и #define из-за их меньшей выразительности и громоздкости.

### 5.2. Не использовать относительные пути в #include директивах.

#include директивы должны содержать только полные пути к файлам, относительно всего проекта или данного программного модуля. В указании пути необходимо использовать только прямой слеш '/'

**_Пример:_**

```cpp
// Неверно
#include "/home/user/my.hpp"
#include "..\common\my.hpp"

// Верно
#include "strings/fast_algorithms/magic/rabin_karp.hpp"
#include "utils/data_dumper.hpp"
```

### 5.3. Каждый написанный заголовочный файл должен компилироваться самостоятельно, т.е. он включает все заголовочные файлы, от которых зависит его содержимое.

Если в заголовочных файлах можно обойтись forward-декларациями, нужно использовать forward-декларации.
Но не стоит усложнять код ради возможности использования forward-деклараций.
Кроме того следует помнить, что объявление forward-деклараций символов из пространства имен std приводит к неопределенному поведению.

**_Пример:_**

```cpp
// Неверно. Даже не компилируется, не хватает заголовочного файла <string>
class StrangeStringView
{
    std::string str_;
};

// Неверно. Не комплируется сам по себе
#include "something_with_string.hpp" // Внутри себя содержит #include <string>
class StrangeStringView
{
    std::string str_;
};

// Верно
#include <string>
class StrangeStringView
{
    std::string str_;
};
```

### 5.4. Не включать заголовочные файлы, которые не используются.

При включении таких файлов попусту тратится время на сборку вашего проекта, так как компилятор анализирует все включенные заголовочные файлы

**_Пример:_**

```cpp
// Неверно, ненужные заголовочные файлы
#include <algorithm>
#include <iterator>
#include <iostream>
#include <iomanip>
#include <cassert>
#include <utility>
#include <string>
#include <vector>
#include <limits>
#include <queue>
#include <cmath>
#include <map>
#include <set>

const int MAX_CONNECTIONS = 1024;
...

// Верно
const int MAX_CONNECTIONS = 1024;
...
```

### 5.5. Inline-функции.

Тело коротких inline-функций можно оставлять на строке декларации функции.

### 5.6. Всегда используйте C++ аналоги заголовочных файлов стандартной библиотеки языка C.
```cpp
// Плохо
#include <math.h>
#include <stdlib.h>

// Хорошо
#include <cmath>
#include <cstdlib>
```

### 5.7. Порядок включения include директив.

* Если это файл реализации, то первой идёт include директива соответствующего заголовочного файла. В двойных кавычках ("").
* Системные заголовочные файлы и заголовочные файлы сторонних библиотек, сгруппированные по библиотеке (примеры: Linux, STL, boost, rapidjson). В угловых скобках (<>).
* Заголовочные файлы всего проекта и данного программного модуля. В двойных кавычках ("").

Рекомендуется группы include директив отделять друг от друга одной пустой строкой.

**_Пример:_**

```cpp
#include "file.hpp" // заголовочный файл данной реализации file.cpp

#include <cstdio>
#include <cstdlib>

#include <fstream>
#include <functional>

#include <boost/algorithm/string/trim.hpp>
#include <boost/spirit/include/classic.hpp>

#include <rapidjson/document.h>
#include <rapidjson/writer.h>

#include "common/uri.hpp"
#include "core/time.hpp"
#include "net-daemon-kit/utils.hpp"
#include "query_params.hpp"
```

### 5.8. Порядок включения секций в заголовочном файле.

* #pragma once для защиты от повторного включения
* #include - директивы
* Прочие декларации

Рекомендуется следующий порядок деклараций:

1. #define, которые должны быть почти исключены
2. Перечисления
3. Константы
4. Forward декларации
5. Декларации классов
6. Декларации вспомогательных функций
7. Тела inline функций

**_Пример:_**

```cpp
#pragma once // для заголовочных файлов

#include <cmath> // системные заголовки

#include "common.hpp" // заголовочные файлы проекта

#define AVOID_MACROS_CONSTANT 404

enum class ErrorCode { ... }; // перечисления
const int MAX_RETRIES = 5; // константы

// Forward декларации
class Future;

// Классы
class ConnectionHandler { ... };

// Вспомогательные функции
int ComputeDistance( const Point & a, const Point & b );

// Тела inline функций (их декларации должны быть в предыдущем блоке)
inline int IsYes( char ch ) { ... };
```

## 6. Модули и пространства имен.

### 6.1. Избегайте кода в глобальной области видимости.

Весь код, за исключением функции main(), должен жить в каком-то namespace, название которого остается на усмотрение автора.

### 6.2. Запрещается использовать using-директивы для пространств имен в заголовочных файлах или перед директивой #include.

При использовании директивы using в заголовочном файле или перед заголовочным файлом можно изменить смысл следующего за using кодом и / или загрязнить пространство имен. Директивы и объявления using предназначены только для вашего удобства и вы не должны использовать их так, чтобы они влияли на какой-то другой код.

Во всех заголовочных файлах, как и в файлах реализации до последней директивы #include, всегда используйте явные полностью квалифицированные имена. В файлах реализации после всех директив #include можно использовать директивы и объявления using.

**_Пример:_**

```cpp
// Неверно
// vector_utils.hpp
#include <vector>

using namespace std;

vector< int > FilterNegative( const vector< int > & vec );

// Верно
// vector_utils.hpp
#include <vector>

std::vector< int > FilterNegative( const std::vector< int > & vec );
```

### 6.3. Анонимные пространства имен и статические переменные.

Старайтесь использовать внутреннюю линковку (internal linkage) для всех определений, которые нужны только локально в пределах
данного cpp-файла. Для этого можно или размещать определения в анонимных пространствах имен, или, в случае переменных и функций,
помечать их как static.

В заголовочных файлах внутреннюю линковку лучше не использовать.

### 6.4. Объявляйте переменные как можно локальнее.

Избегайте «раздувания» областей видимости. Переменных должно быть как можно меньше, а время их жизни - как можно короче.

Переменные, время жизни которых превышает необходимое, имеют ряд недостатков.
* Они делают программу трудно понимаемой и сопровождаемой.
* Они засоряют контекст своими именами.
* Они не всегда могут быть корректно инициализированы.

Чем более широкой является область видимости идентификатора, тем более длинным и осмысленным должно быть его имя.

**_Пример:_**

```cpp
// Неверно
int local_var = 1;
// 10-20 строчек кода, не использующих local_var
...
int result = local_var * ( ... );

// Верно
// 10-20 строчек кода не использующих local_var
...
int local_var = 1;
int result = local_var * ( ... );
```

### 6.5. Желательно избегать декларации перечислений, констант и типов вне декларации класса, который их использует.

Размещать декларации типов и констант нужно в минимально узкой области видимости, в которой они используются. Желательно не дальше class, однако, если тип требуется вне класса, то можно в соответствующем namespace.

Для перечисляемых типов строго рекомендуется использовать enum class, вместо enum, т.к. его можно в случае необходимости разместить вне класса.

**_Пример:_**

```cpp
// Объявляем класс и перечисление внутри него
class CTest
{
public:
    enum class Color
    {
        BLACK,
        WHITE
    };
    // ...
};

// Где-то в программе
CTest::Color::BLACK;
```

### 6.6. Всегда инициализируйте переменные при определении.

Неинициализированные переменные - распространенный источник ошибок в программах на C и C++. Надо избегать их, инициализируя переменные при их определении.

**_Пример:_**

```cpp
// Не верно: не инициализирует переменную
int speedup_factor;
if( condition )
    speedup_factor = 2;
else
    speedup_factor = -1;

// Верно: инициализирует переменную
int speedup_factor = -1;
if( condition )
    speedup_factor = 2;

// Верно: инициализирует переменную
int speedup_factor = condition ? 2 : -1;
```

### 6.7. Минимизируйте глобальные совместно используемые данные.

Избегайте совместного использования данных, в особенности глобальных данных. Совместно используемые данные усиливают связность, что приводит к снижению сопровождаемости, а зачастую и производительности.

При использовании статических переменных с нетривиальной инициализацией внутри динамически линкуемых библиотек могут возникать проблемы при выгрузке и загрузке вплоть до падения. Этого следует избегать.

### 6.8. При использовании функций стандартной библиотеки языка C явно указывайте пространство имен std.
```cpp
// Очень плохо
#include <math.h>

int x = abs( y );

// Хорошо
#include <cmath>

int x = std::abs( y );
```

## 7. Классы.

### 7.1. В конструкторах предпочитайте инициализацию присваиванию.

**_Пример:_**

```cpp
class SomeClass
{
public:
    SomeClass()
    :   s2_( "string2" ) // Хорошо. Инициализация.
    {
        // Не оптимально. Присваивание после того
        // как отработал дефолтовый конструктор,
        // вызов которого можно было избежать.
        s3_ = "string3";
    }

private:
    // Хорошо. Инициализация
    std::string s1_ = "string1";
    std::string s2_;
    std::string s3_;
};
```

### 7.2. Делегирование конструкторов.

С появлением возможности делегирования конструкторов в С++11, стоит отдавать предпочтение их использованию, нежели старому подходу с созданием отдельного метода для инициализации.

Старый подход:

```cpp
StringBuilder::StringBuilder()
{
    Init(); // Метод содержит общий код инициализации
}

StringBuilder::StringBuilder( const std::string & str )
{
    Init();
    // ...
}

StringBuilder::StringBuilder( const char * str )
{
    Init();
    // ...
}
```

Новый предпочтительный подход:

```cpp
StringBuilder::StringBuilder()
{
    // Общий код инициализации
}

StringBuilder::StringBuilder( const std::string & str )
:   StringBuilder()
{
    // ...
}

StringBuilder::StringBuilder( const char * str )
:   StringBuilder()
{
    // ...
}
```

### 7.3. Избегайте возможностей неявного преобразования типов. Используйте директиву explicit.

Неявные преобразования типов имеют две основные проблемы:

* Они могут проявиться в самых неожиданных местах.
* Они не всегда хорошо согласуются с остальными частями языка программирования.

Используйте следующие правила:

* Используйте explicit в конструкторах с одним аргументом.
* Используйте для преобразования типов именованные функции, а не операторы приведения. Наподобие string.c_str().

**_Пример:_**

```cpp
// Использование explicit в конструкторе
class Widget
{
    // ...
    explicit Widget( unsigned int factor );
    explicit Widget( const char * data, const Widget * other = 0 );
};

// Преобразование типов как функция класса
class BigNumber
{
    // ...
    explicit BigNumber( int64_t value );
    const std::string & ToString() const;
};
```

**_Пример:_**

```cpp
// Неявное преобразование приводит к ошибке
class Widget
{
    //...
    Widget( unsigned int factor );
};

void Display( double ); // Вывод double
void Display( const Widget & ); // Вывод Widget
Display( 5 ); // Плохо - создание и вывод Widget
```

### 7.4. Явно разрешайте или запрещайте копирование.

При проектировании класса разработчик, как правило, точно знает о возможности копировать объекты своего класса. Выполнение данного правила "заставит" других разработчиков, использующих класс понять это.

**_Пример:_**

```cpp
// Запретим копирование
class T
{
public:
    T( const T & ) = delete;
    T & operator=( const T & ) = delete;
};
```

Для запрещения копирования можно использовать наследование от класса boost::noncopyable

**_Пример:_**

```cpp
#include <boost/utility.hpp>
class SomeClass : boost::noncopyable {};
```

### 7.5. Move-конструкторы.

move-конструкторы обеспечивают семантику перемещения ресурсов. Это особенно важно, чтобы избежать копирования больших объектов.

```cpp
class HeavyClass
{
    HeavyClass( HeavyClass && o )
    {
        fat_storage_ = o.fat_storage_;
        o.fat_storage_ = nullptr;
    }
};
```

Иногда move-constructor-ы являются единственным средством, ввиду семантики объекта. Например, объект реализующий сокет, не должен быть копируемым. И, в случае передачи этого объекта, семантика перемещения - изящный выход:

```cpp
class Socket
{
    Socket( Socket && o )
    {
        fd_ = o.fd_;
        o.fd_ = -1;
    }
}

void MakeHttpConnection( KeepAlivePool & pool )
{
    Socket s;
    // ...
    pool->DelegateConnection( std::move( s ) );
}
```

### 7.6. Копируйте и ликвидируйте согласованно.

Копирующий конструктор и оператор копирующего присваивания - взаимосвязаны. Для них действуют следующие правила:

* Если вы пишите или запрещаете копирующий конструктор, или оператор копирующего присваивания, вероятно, вы должны сделать то же самое и для другой функции из этой пары.
* Если вы явно пишете копирующие функции, вероятно, вам надо явно написать и деструктор.
* Если вы явно пишете деструктор, вероятно, вам требуется явно написать или явно запретить копирование.

### 7.7. Для простой переноски данных следует использовать struct вместо class.

Если класс не содержит нетривиальной логики по обработке данных, а предназначен просто для группировки нескольких полей, то для таких целей следует использовать struct.

В struct не следует использовать спецификаторы доступа, соответственно все поля являются публичными.
Названия полей в структуре, в отличие от класса, не должны содержать подчеркиваний на конце.

Если по мере развития кода в структуре возникла необходимость добавления логики обработки данных, её следует преобразовать в класс.

**_Пример:_**

```cpp
// Простая группировка данных
struct Point
{
    double x;
    double y;
};

// Возникла необходимость в добавлении логики обработки данных
class Point
{
public:
    void Normalize();
    double CalcHypot() const;
    // ...

private:
    double x_;
    double y_;
};
```

### 7.8. Не следует использовать std::pair и std::tuple там, где их можно заменить на struct.

Эти стандартные классы являются упрощенной альтернативой struct, поскольку их объявление требует меньше кода.
Однако это достоинство не перекрывает их недостатков: отсутствия понятных названий у полей и плохой масштабируемости.

**_Пример:_**

```cpp
// Неверно, т.к. поля называются first и second
// Если потребуется добавить ещё одно поле, std::pair придётся выкинуть
using Point = std::pair< double, double >;

// Верно
struct Point
{
    double x;
    double y;
};

// Неверно, т.к. у полей нет названий, только индексы
// Добавление поля без смещения индексов возможно только в конец
using Point = std::tuple< double, double, double >;

// Верно
struct Point
{
    double x;
    double y;
    double z;
};

```

### 7.9. Использование наследования и виртуальных функций должно быть разумным, а глубина иерархии не должна превышать 5 уровней.

### 7.10. Предпочитайте минимальные и узкоспециализированные классы большим и многопрофильным.

Небольшие классы легче писать, тестировать и использовать. Минималистичный и узкоспециализированный класс проще в использовании, его легче понять, проще поддерживать и проще тестировать. Большие и многопрофильные классы сложнее сделать корректными и безопасными.

### 7.11. Предпочитайте композицию наследованию.

Наследование - вторая по силе после отношения дружбы взаимосвязь, которую можно выразить в C++. Сильные связи нежелательны, и их следует избегать везде, где только можно. Композиция имеет важные преимущества над наследованием.
* Большая гибкость без влияния на вызывающий код: закрытые члены-данные находятся под полным вашим контролем.
* Большая обособленность в процессе компиляции, уменьшение времени компиляции. При хранении члена класса посредством указателя можно снизить зависимости заголовочных файлов, поскольку объявление указателя на объект не требует полного определения этого класса.
* Большая применимость. Не все классы проектируются с учетом того, что они будут выступать в роли базовых.
* Большая надежность и безопасность. Более сильное связывание путем наследования затрудняет написание безопасного в смысле ошибок кода.
* Меньшая сложность и хрупкость. Наследование приводит к дополнительным усложнениям, таким как сокрытие имен и другим, возникающим при внесении изменений в базовый класс.

**_Пример:_**

```cpp
// Вместо наследования классов
class B
:   public A
{
    // ...
};

// Можно использовать композицию классов
class B
{
    std::unique_ptr< A > a_;
    // ...
};
```

### 7.12. Переопределение виртуальных методов.

В случае переопределения виртуальные методы необходимо помечать ключевым словом override во избежание возникновения ошибок при изменении сигнатуры родительского метода.

Пример корректно оформленного кода:

```cpp
class Animal
{
public:
    virtual const char * MakeSound() const;
};

class Cat
:   public Animal
{
public:
    const char * MakeSound() const override;
};
```

Рассмотрим ошибку, которая может возникнуть при игнорировании правил переопределения.

Шаг №1: Некорректно переопределяем метод:

```cpp
class Cat
:   public Animal
{
public:
    const char * MakeSound() const;
};
```

Шаг №2: Меняем сигнатуру родительского метода:

```cpp
class Animal
{
public:
    virtual std::string MakeSound() const;
};
```

Получаем незамеченную компилятором ошибку: метод Cat::MakeSound больше не переопределяет Animal::MakeSound, а существует сам по себе. Этого не возникнет при использовании ключевого слово override.

### 7.13. Аргументы по умолчанию для виртуальных методов.

Настоятельно не рекомендуется использовать аргументы по умолчанию для виртуальных методов. Так как при вызове виртуального метода по ссылке/указателю, вызывается "правильная" реализация для текущего объекта, а вот значения аргументов по умолчанию - определяются по типу ссылки или указателя. Это чревато трудноуловимыми ошибками.

Однако, если возникла непреодолимая потребность в аргументах по умолчанию для виртуальны методов, то **необходимо** в каждом наследующем классе их явно прописывать строго с теми же самыми значениями по умолчанию, что указаны у базового класса.

Пример использования аргументов по умолчанию для виртуальных методов у нас в репозитории:


```cpp
struct ICluster
{
    virtual ~ICluster() {}
    virtual bool IsInitialized() const = 0;

    virtual GetFuturePtr Get( int64_t key, const RecordParams & params = RecordParams() ) = 0;
};

class ClusterImpl;

class Cluster
:   boost::noncopyable,
    public ICluster
{
public:
    Cluster( const Config & config );
    ~Cluster();

    virtual GetFuturePtr Get( int64_t key, const RecordParams & params = RecordParams() ) override;
};
```

```cpp
GetFuturePtr Cluster::Get( int64_t key, const RecordParams & params )
{
    // it's necessary because Cluster::GetRecordParams could override RecordParams::set_name
    // and the set_name affects the Digest
    auto record_params = pimpl_->GetRecordParams( params );
    return pimpl_->Get( Digest( key, record_params.set_name ), record_params );
}

RecordParams ClusterImpl::GetRecordParams( const RecordParams & params ) const
{
    auto record_params = config_.default_record_params;
    record_params.Merge( params );
    return record_params;
}
```

### 7.14. Крайне не рекомендуется перегружать бинарные операторы &&, || и , (запятая)

Встроенные операторы &&, || и , (запятая) трактуются компиляторами специальным образом. После перегрузки они становятся обычными функциями с весьма отличной семантикой, а это прямой путь к трудноопределимым ошибкам и непредсказуемому поведению. Не перегружайте данные операторы без крайней необходимости и серьёзной мотивации.

**_Пример:_**

```cpp
// Всё корректно
Employee * employee = GetEmployee();
if( employee && employee->IsManager() )
    // ...

// Так как до выполнения кода функции всегда вычисляются все аргументы,
// а порядок вычисления аргументов функции не определен,
// то потенциально может вызваться employee->Маnаger()
// при нулевом значении employee, если вдруг для
// типа SmartPtr переопределен operator &&
my::SmartPtr< Employee > employee = GetEmployee();
if( employee && employee->IsManager() )
    // Не делайте так
```

### 7.15. Все данные-члены класса должны быть private или protected, исключение составляют static const данные.

**_Пример:_**

```cpp
// Неверно
class Color
{
public:
    int color_;
    // ...
};

// Верно
class Color
{
public:
    int GetColor() const;
    void SetColor( int color );

public:
    static const Color BLACK;

private:
    int color_;
};
```

### 7.16. Порядок следования секций внутри декларации класса: public, protected, private. Порядок следования внутри секции: типы, методы, мемберы. Для читаемости, типы, методы и мемберы внутри секции следует отделять друг от друга указав имя секции снова.

**_Пример:_**

```cpp
class GeometryExample
{
public:
    using Point = GenericPoint< int, int >;
    ...

public:
    float ComputeDistance( const Point & p1, const Point & p2 ) const;
    ...

public:
    static const float PI_NUMBER;
    ...

protected:
    ...

private:
    Point center_;
    ...
};
```

### 7.17. Не допускайте вмешательство во внутренние дела класса.

Избегайте возврата дескрипторов внутренних данных, управляемых вашим классом, чтобы клиенты не могли неконтролируемо изменять состояние вашего объекта.

**_Пример:_**

```cpp
// Неверно. В этом случае клиент может напрямую работать со значением,
// которое вернулось в методе GetHandle(например, закрыть его),
// а класс Socket об этом ничего не узнает
class Socket
{
public:
    // ...
    int GetHandle() const { return handle_; }

private:
    int handle_;
};
```

### 7.18. Getter'ы и Setter'ы.

Реализацию простых getter'ов и setter'ов в заголовочном файле допустимо оставлять на одной строке с их определением. Если в какой-то момент они перестают быть простыми, то их необходимо перенести в файл реализации.

```cpp
class AmazingRanker
{
public:
    // Допустимо оставить getter в заголовочном файле вместе с определением в той же строке
    float GetRank() const { return rank_; }

    void SetRank( float rank );

private:
    float rank_ = 0.0f;
};

// Файл реализации
void AmazingRanker::SetRank( float rank )
{
    if( rank < 0.0f || rank > 1.0f )
    {
        throw std::out_of_range( "The value of rank is out of range: [0, 1]." );
    }
    rank_ = rank;
}
```

## 8. Функции.

### 8.1. Необходимо избегать длинных функций и глубокой вложенности.

Чрезмерно большая по размеру функция и чрезмерная вложенность блоков (например, блоков if, for, while и try) делают функции более трудными для понимания и сопровождения, причем зачастую без каких бы то ни было основании.

Желательно, чтобы размер одной функции не превышал 50 строк кода, а блок кода 10-30 строк. Число уровней вложенности функции не должно превышать 3 - 4.

Предпочтительно использовать практику раннего возврата (early return) при написании кода, чтобы сократить количество отступов.

**_Пример:_**

```cpp
// Плохо
void Config::Find( const char * section, const char * key, std::vector< std::string > & v ) const
{
    v.clear();

    config_data::const_iterator it = data.find( section );
    if( it != data.end() )
    {
        config_section_res res = it->second.equal_range( key );

        if( res.first != res.second )
        {
            config_section::const_iterator it1 = res.first;
            for( ; it1 != res.second; ++it1 )
                v.push_back( it1->second );
        }
    }
}

// Лучше
void Config::Find( const char * section, const char * key, std::vector< std::string > & v ) const
{
    v.clear();

    config_data::const_iterator it = data.find( section );
    if( it == data.end() )
        return;

    config_section_res res = it->second.equal_range( key );

    if( res.first == res.second )
        return;

    config_section::const_iterator it1 = res.first;
    for( ; it1 != res.second; ++it1 )
        v.push_back( it1->second );
}
```

### 8.2. Передача параметров по значению, указателю, интеллектуальному указателю или ссылке.

Для входных параметров, которые передают информацию в функцию, но не возвращают её:

* Всегда описывайте все указатели или ссылки на входные параметры как const.
* Предпочитайте передачу примитивных типов (например, char или float) по значению.
* Входные аргументы прочих пользовательских типов лучше передавать как ссылки на const.
* Подумайте о передачи по значению вместо передачи по ссылке если функция требует создания копии аргумента.

Для выходных параметров, а также параметров для одновременного ввода и вывода информации:

* Если выходной параметр всего один, а функция не имеет возвращаемого значения, то необходимо использовать return.
* Если аргумент необязателен, лучше передать его как указатель, что позволит вызывающей функции передать нулевое значение как указание того, что аргумент отсутствует; Этот же совет применим и в случае, если функция сохраняет копию указателя или как-то иначе работает с принадлежностью аргумента.
* Если аргумент обязательный и функция не сохраняет указатель на него и никаким иным образом не влияет на его принадлежность, то такой аргумент лучше передавать по ссылке. Это указывает, что наличие данного аргумента обязательно, и заставляет вызывающую функцию отвечать за предоставление корректного объекта.
* Выходные параметры функции рекомендуется указывать после входных.

### 8.3. Не пишите код, который зависит от порядка вычислений аргументов функции.

Порядок вычисления аргументов функции не определен, поэтому никогда не полагайтесь на то, что аргументы будут вычисляться в той или иной очередности.

**_Пример:_**

```cpp
void Modify( int, int );

// Неверно, так как порядок вычислений неизвестен
int count = 5;
Modify( ++count, ++count );

// Верно
int incremented_once = ++count;
Modify( incremented_once, ++count );
```

## 9. Умные указатели и управление памятью.

### 9.1. Вместо указателей на динамическую память желательно пользоваться «умными» указателями и стандартными контейнерами.

Везде, где это возможно, необходимо использовать умные указатели и классы, инкапсулирующие ресурсы. Например scoped_ptr, shared_ptr, а также стандартные контейнеры STL.

Выгода такого подхода заключается в том, что ресурсы освободятся автоматически при выходе из области видимости.

**_Пример:_**

```cpp
// Не рекомендуется. Есть вероятность утечек памяти.
void MakeSomeWork()
{
    // ...
    int * int_array1 = new int [ length ];
    int * int_array2 = new int [ length ];

    FillArray( int_array1, length );
    FillArray( int_array2, length );

    bool success = Check( int_array1, length, int_array2, length );
    if( !success )
    {
        delete[] int_array1;
        delete[] int_array2;
        return;
    }

    int result = CalcFunc( int_array1, length, int_array2, length );
    if( result != -1 )
    {
        delete[] int_array1;
        delete[] int_array2;
        return;
    }

    // ...
    delete[] int_array1;
    delete[] int_array2;
}

// Вариант с использованием контейнера. Вероятность утечек - минимальна.
void MakeSomeWork()
{
    // ...
    std::vector< int > int_array1( length );
    std::vector< int > int_array2( length );

    FillArray( int_array1 );
    FillArray( int_array2 );

    bool success = Check( int_array1, int_array2 );
    if( !success )
        return;

    int result = CalcFunc( int_array1, int_array2 );
    if( result != -1 )
        return;

    // ...
}
```

### 9.2. Используйте unique_ptr и shared_ptr для указателей.

Не используйте явное освобождение памяти. Вместо этого, опирайтесь на RAII, используя unique_ptr/shared_ptr. Следует отметить, что unique_ptr не несет абсолютно никакого overhead по сравнению с прямой работой с памятью. Используйте его по-умолчанию.

Используйте shared_ptr, только если объект действительно нуждается в разделении владения. Например, иногда программисты по-привычке возвращают из методов shared_ptr. Если при этом объект не нуждается в разделении ресурсов, то достаточно unique_ptr.

```cpp
// Например, такой код
std::shared_ptr< QueryTree > GetQueryTree( const std::string & query ) { ... }

// Практически всегда может быть заменен на
std::unique_ptr< QueryTree > GetQueryTree( const std::string & query ) { ... }
```

Явному вызову shared_ptr/unique_ptr предпочитайте вызов make_shared/make_unique. Помимо сокрытия явного аллоцирования YourClass, ваш код не попадет в такие нетривиальные проблемы как следующая (стоит заметить, что в С++17 эта проблема уже пофикшена):

```cpp
// Что будет, если конструктор BadObj бросит исключение?
// Ведь стандартом не определен порядок вычисления аргументов.
f( std::shared_ptr< Obj >( new Obj( "foo" ) ), std::shared_ptr< BadObj >( new BadObj( "bar" ) ) );

// Здесь такая проблема невозможна:
f( std::make_shared< Obj >( "foo" ), std::make_shared< BadObj >( "bar" ) );
```

Кроме того, вызов make_shared является очень полезной оптимизацией, т.к. позволяет не аллоцировать под контрольный блок отдельный кусок памяти, а хранить его рядом с данными.

make_unique следует использовать для единообразия и консистентности кода. Кроме того, это может иметь своё преимущество, так как если вдруг указателю нужно будет изменить тип из unique_ptr в shared_ptr, вы не забудете где нужно вызвать make_shared, просто заменив соответствующие вызовы make_unique. Таким образом, вы предусмотрительно избежите попадания в вышеобозначенную ситуацию.

Обратите внимание, что unique_ptr и shared_ptr можно также использовать с явным указанием деструктора. Это полезно, например для оборачивания типа FILE из libc:

```cpp
std::unique_ptr< FILE, decltype( &fclose ) > f1( fopen( "/etc/passwd", "r" ), fclose );
std::shared_ptr< FILE > f2( fopen( "/etc/passwd", "r" ), fclose );
```

### 9.3. Не используйте auto_ptr.

auto_ptr является устаревшим. Семантика передачи владения и сама реализация приводят к ужасно долгим отладкам. Вместо него всегда используйте unique_ptr.

### 9.4. Необходимо придерживаться правила: "Кто выделил ресурсы, тот и должен их освободить".

Нарушение этого правила должно четко оговариваться в документации и в комментариях к модулю.

При проектировании своих классов старайтесь не выдавать наружу указатель или описатель ресурса (file id, socket id, process id...), которым владеет объект класса.

## 10. Обработка ошибок, исключения.

### 10.1. Для уведомлений об ошибках рекомендуется использовать исключения.

В C++ сообщения об ошибках посредством исключений имеют явные преимущества перед уведомлением посредством кодов ошибок.

* Исключения невозможно игнорировать.
* Исключения распространяются автоматически. Коды ошибок, по умолчанию, не распространяются за пределы области видимости.
* Исключения выносят обработку ошибок и восстановление после них из основного потока управления.
* Исключения оказываются наилучшим способом уведомления об ошибках в конструкторах и операторах.

Механизм исключения необходимо использовать только при возникновении и обработке ошибок. Не используйте исключения для простой передачи данных внутри программы, так как это может сказаться на производительности.

**_Пример:_**

```cpp
int FindFirstBig( int * values, int size, int min )
{
    int result = -1;
    // Плохо. Исключения используются для передачи данных.
    try
    {
        for( int i = 0; i < size; i++ )
        {
            if( values[i] > min )
                throw i;
        }
    }
    catch( int n )
    {
        result = n;
    }
    return result;
}

// Хорошо: произошла исключительная ситуация, выбрасываем исключение
template < typename T >
class AlignedVector
{
    const T & at( size_t pos ) const
    {
        if( pos < 0 || pos > size_ )
            throw std::out_of_range( "AlignedVector: out of range" );
        ...
    }
};
```

### 10.2. Крайне не рекомендуется использовать конструкцию catch( ... ). Необходимо явно указывать типы исключений, которые нужно обрабатывать, если это возможно.

**_Пример:_**

```cpp
// Неверно
try
{
    MysteriousFunction();
}
catch( ... )
{
    LogError( "Oh no! Something goes wrong. Just let it go." );
}

// Верно
try
{
    MysteriousFunction();
}
catch( const MostSpecificException & e )
{
    LogError( "Catch MostSpecificException in module name: " + e.what() );
}
catch ( const LessSpecificException & e )
{
    LogError( "Catch LessSpecificException in module name: " + e.what() );
}
```

### 10.3. Генерируйте исключения по значению, перехватывайте — по ссылке. Объект исключения должен быть наследником от std::exception.

Генерируйте исключения по значению, не через указатель, и перехватывайте их как ссылки, как правило - константные.

При генерации по значению компилятор сам отвечает за запутанный процесс управлению памятью, выделенной генерируемому объекту. Всё что требуется от вас - это принять меры для гарантии того, что копирующий конструктор класса вашего исключения не может генерировать исключений.

При повторной генерации исключения - лучше просто писать оператор throw; вместо инструкции throw е. Дело в том, что первый способ всегда сохраняет полиморфизм объекта повторно генерируемого исключения.

### 10.4. Деструкторы не должны выбрасывать исключения.

Если деструктор выкинет исключение, будучи сам вызван в процессе обратной раскрутки стека при исключении, то будет вызван метод terminate. Это неприемлемо, поэтому исключения в деструкторе выбрасывать недопустимо.

Функции освобождения ресурсов также надо делать безопасными для исключений, иначе может произойти утечка ресурсов.

### 10.5. Можно использовать исключения в конструкторах классов.

Если конструктор не способен успешно создать объект своего типа, он должен сгенерировать исключение.

При использовании исключений в конструкторах классов не допускайте утечек ресурсов, освобождайте все выделенные ресурсы, так как при возникновении исключения в конструкторе, не будет вызван деструктор для еще не созданного объекта.

### 10.6. Запрещено использовать динамические (old-style) спецификации исключений.

Спецификация исключений образует теневую систему типов, которая ведет к затруднению сопровождения кода.
Спецификатор noexcept использовать можно, т.к. в отдельных случаях он помогает сделать код быстрее.

### 10.7. Не позволяйте исключениям пересекать границы модулей.

Если в состоянии контролировать, каким компилятором и с какими опциями скомпилированы обе части кода, то в этом случае можно позволить исключению пересекать границы модулей.

Механика распространения исключений варьируется не только в зависимости от операционной системы и компилятора, но и в зависимости от опции компиляции, использованных для компиляции данного модуля, данным компилятором, в данной операционной системе.

На границах модуля можно использовать стратегию преобразования исключений к кодам ошибок, и наоборот.

### 10.8. Применяйте assert для документирования внутренних допущений.

Используйте assert для документирования внутренних допущений в модуле, которые должны всегда выполняться.

**_Пример:_**

```cpp
// Проверка базовых допущений
std::string Date::DayOfWeek() const
{
    assert( day_ > 0 && day_ <= 31 );
    assert( month_ > 0 && month_ <= 12 );
    // ...
}
```
He используйте assert для сообщений об ошибках времени выполнения. Например, не следует применять assert, чтобы убедиться в корректной работе malloc, успешном запуске потока программы или для проверки данных, прочитанных из конфиг-файла. Однако, можно использовать assert, чтобы убедиться, что API работает так, как документировано.

### 10.9. Все сообщения об ошибках в логах должны быть написаны на английском языке.

**_Пример:_**

```cpp
// Неверно
LogError( "Вот это да, почему-то ваш запрос обрабатывается слишком долго" );

// Верно
LogError( "Oh, no, you query taking too long" );
```


## 11. Типы и их преобразования.

### 11.1. Целочисленные типы.

Для целочисленных типов старайтесь использовать типы с явным указанием размера: int16_t вместо short, uint16_t вместо unsigned short, int64_t вместо long long и так далее. В случаях, когда размер значения не имеет можно использовать просто int.

```cpp
// Не очень хорошо
unsigned short small_counter = 0;

// Лучше
int16_t small_counter = 0;
```

### 11.2. Используйте явное преобразование типов только в тех местах, где это действительно необходимо. Явное преобразование типов необходимо использовать в стиле C++.

Замена преобразования в стиле С преобразованиями С++ помогает защититься от неожиданных ошибок.

Используйте static_cast для преобразования между целыми вещественными и перечислимыми типами.

Избегайте использования dynamic_cast для нисходящего привидения типов (downcast), как правило, потребность в нём свидетельствует о недостаточно продуманной иерархии классов.

В общем случае использовать const_cast и reinterpret_cast не рекомендуется. Их применение возможно только в особых случаях с обязательным подробным комментированием кода.

### 11.3. Пcевдонимы типов (typedef и using)

Для сложносоставных типов, если они используются в нескольких местах, настоятельно рекомендуется присвоить этому типу имя при помощи typedef-объявления или псевдоним, используя using. Под сложносоставным типом подразумевается:

* Шаблонный тип с 2-мя и более шаблонными аргументами
* Вложенные шаблонные типы (шаблон в шаблон)

При прочих равных следует использовать using. Если в файле уже используется typedef, то следует так же использовать typedef для консистентности.

```cpp
// Верно
using Url2DocHash = std::unordered_map< std::string, int64_t >;

// Также верно
typedef std::vector< std::shared_ptr< SignalEvent > > SignalEventList;

// Верно и это
class Cluster
{
    BatchGetFuturePtr BatchGet( const std::vector< std::string > & key_names );

private:
    std::unique_ptr< ClusterImpl > pimpl_;
};

// В данном случае необходимо использовать using
template< class T, class Container = std::vector< T >,
          class Compare = std::greater< typename Container::value_type > >
using LimitedMinHeap = LimitedHeap< T, Container, Compare >;
```

## 12. Операторы и выражения.

### 12.1. Допускается использование оператора присваивания внутри условного оператора if.

**_Пример:_**

```cpp
// Верно
if( FileHandler file_id = OpenFile( name ) )
{
    // ...
}

// Верно
FileHandler file_id = OpenFile( name );
if( file_id )
{
    // ...
}
```

### 12.2. Пользуйтесь скобками для явного указания порядка выполнения операторов, если это улучшает читаемость.

**_Пример:_**

```cpp
if( it != values.end() && current_result > ( value1 - value2 ) )
{
    //...
}
```

### 12.3. Избегайте слишком сложных выражений.

Такие выражения затрудняют поддержку и сопровождение кода. Во избежание неоправданного усложнения кода рекомендуется:

* Разбить исходное сложное выражение на несколько простых выражений (функции).
* Не стремиться к излишней оптимизации кода там, где это сильно усложняет понимание кода.
* Использовать принцип Explaining Variables, т.е. введение дополнительных переменных (или функций) агрегирующих в себе часть логики сложного выражения для последующего их использования в финальном вычислении (функций).

**_Пример 1:_**

```cpp
// Неверно
if( ( ptr = GetPointer() ) != 0 )
    url_length = data + idx++ - pos;

// Верно
if( ( ptr = GetPointer() ) )
{
    url_length = data + idx - pos;
    ++idx;
}
```

**_Пример 2:_**

```cpp
// He верно. Слишком сложное выражение
if ( query_param.value == 1 ||
     query_param.value == 'Y' ||
     query_param.value == '1' )
    ctx->IsEnabled = 1;
else
    ctx->IsEnabled = 0;

// Вводим новую функцию
bool IsAffirmativeAnswer( char ch )
{
    return ch == 1 || ch == 'Y' || ch == '1';
}
// Упрощенный вариант
ctx->IsEnabled = IsAffirmativeAnswer( query_param.value );
```

### 12.4. Предпочитайте вызов префиксных операторов ++ и --

Используйте префиксные версии операторов, так как они зачастую эффективнее, потому что при этом не создаётся временных объектов. Если только вам не требуется исходное значение.

### 12.5. Словесные имена операторов.

Не используйте словесные имена операторов: and, or.

## 13. Сonst-корректность.

### 13.1 Требуется всегда указывать const.

Делайте константными:

* **Методы классов, если этот метод не изменяет внутренних членов класса**
* **Параметры функций, если эти переданный объект внутри метода не изменяется**
* **Внутренние члены классов, если их изменение в течение жизни объекта не подразумевается**

Указание const не регламентируется строго и допускается на усмотрение автора, при работе со встроенными типами (int, float, ...), объектами размещёнными на стеке и возвращаемыми значениями.

### 13.2. Избегайте задания константных значений в коде, а также использования макросов для объявления констант.

Избегайте использования в коде литеральных констант наподобие "RED" и 3.1415926. Такие константы не самоочевидные и усложняют сопровождение кода. Вместо таких литеральных констант используйте символьные константы.

**_Пример:_**

```cpp
// Объявление константы из предметной области на уровне пространства имен
const size_t PAGE_SIZE = 8192;
```

Вместо define определений для перечисляемых типов надо использовать enum class.

```cpp
// Не верно
#define MAX_SIZE 100

// Верно
const size_t MAX_SIZE = 100;

// He верно
#define GOOD_RESULT 0
#define BAD_RESULT 1

// Верно
enum class OperationResult
{
    GOOD = 0,
    BAD = 1
};
```

## 14. Макросы.

### 14.1. Необходимо избегать использования макросов.

В тех случаях, когда использование макросов действительно необходимо, его размер не должен превышать 2-3 строк кода, а область действия макроса должна быть как можно компактнее (используем #undef).

Ошибка в макросе обнаруживается только после того, как макрос раскрывается, а не при его определении. Макросы могут быть раскрыты в нечто, что в силу чистой случайности, скомпилируется, не имея при этом никакого смысла. Практически всегда можно избежать использования макросов. Надо использовать const или enum class для определения явных констант, inline для того, чтобы избежать накладных расходов на вызов функции, template для определения семейств функций и типов, и namespace для того, чтобы избежать конфликта имен.

Исключения:

* Использование директив ifdef и #if defined для условной компиляции.
* Реализации assert.
* Макросы для обработки кодов ошибок, логирования и т.п.

## 15. Отдельные элементы C++11.

### 15.1. Использование std::initializer_list.

Предпочитайте использование нового синтаксиса с std::initializer_list, вместо boost::assign, так как это более читаемо и не требует дополнительных зависимостей.

Примеры оформленного в новом стиле кода:

```cpp
static const std::map< int, std::string > INT2STR = {
    { 0, "ноль" },
    { 1, "один" },
    { 2, "два" },
    { 3, "три" },
    { std::numeric_limits< int >::max(), "много" }
};

static const std::vector< std::string > DEADLY_SINS = {
    "greed",
    "pride",
    "envy",
    "sloth",
    "wrath",
    "gluttony",
    "lust",
    "c-style cast"
};
```

### 15.2. Использование лямбда-функций.

Лямбда-функции идеально подходят для написания небольших функторов и предикатов. Объёмные вставки лямбда-кода ухудшают читабельность, кроме того, применение анонимных лямбда функций создаёт дополнительные сложности в понимании кода. Программист использует имена обычных функций/методов как подсказку, говорящую об их назначении. Эмпирическое правило таково: допустимо выносить до 10 строк кода в лямбда-функции, но всю нетривиальную логику необходимо вынести в именованные методы/функции.

Запрещается захватывать все переменные из области видимости с помощью конструкции [=] или [&], вместо этого надо явно перечислить их по одной.

Примеры удачных применений лямбда-функций:

```cpp
std::count_if( sheeps.begin(), sheeps.end(), []( const Sheep & sh ) { return sh.IsJumping(); } );

std::transform(
    cars.begin(), cars.end(),
    robots.begin(),
    []( const Car & car )
    {
        if( !car.IsTransformer() )
            return nullptr;

        return car.MakeGiantRobot();
    }
);
```

Примеры плохих применений:

```cpp
int yarr [ 128 ];
State state;
std::generate_n( yarr, std::size(N),
    [ &state ]()
    {
        // Код не очень длинный, но нетривиальный,
        // и намного лучше будет его изолировать
        state.x ^= state.x << 16;
        state.x ^= state.x >> 5;
        state.x ^= state.x << 1;
        int t = state.x;
        state.x = state.y;
        state.y = state.z;
        state.z = t ^ state.x ^ state.y;
        return state.z;
    }
);

// Исправленная версия:
std::generate_n( yarr, std::size(N),
    [ &state ]()
    {
        UpdateState( state );
        return state.z;
    }
);
```

### 15.3 auto

Использование ключевого слова auto (C++11) не допускается, кроме нижеперечисленных паттернов. Если читателю известны другие случаи, когда auto улучшает читабельность кода, просьба вынести это на обсуждение.

```cpp
// range-based for по map/unordered_map
for( const auto & socks_pair : sockets )
{
    int descriptor = socks_pair.first; // объявляем явно, чтобы дать читателю информацию о типах
    Socket & sock = socks_pair.second;

    // остальной код, где используются объявленные ключ и значение
    // объявлять неиспользуемые ключ/значение не нужно
}

// стандартные алгоритмы, возвращающие итераторы
auto key_it = std::find( car_keys.begin(), car_keys.end(), LOST_KEY_ID );

// переменные под lambda-функции (например, для предиката)
auto is_it_okay_to_have_dinner = []( int hour )
{
    return hour < 13 || hour == 15 || hour > 17;
};

```

### 15.4 STL и boost

При выборе стандартной библиотеки следует отдавать приоритет STL над boost, если там уже имеется необходимая функциональность.

```cpp
// Неверно: в стандартной библиотеке существует аналог.
boost::shared_ptr< SomeClass > class_ptr_;

// Верно:
std::shared_ptr< SomeClass > class_ptr_;

// Верно: в стандартной библиотеке отсутствует аналог boost::geometry
using point_type = boost::geometry::model::d2::point_xy< double >;
```
